#pragma once

#include <memory>
#include <functional>
#include <utility>

// ??????????????????????????????????????????????????????????????
// Platforma
// ??????????????????????????????????????????????????????????????
#if defined(_WIN32) || defined(_WIN64)
#ifndef EG_PLATFORM_WINDOWS
#define EG_PLATFORM_WINDOWS
#endif
#else
#error "This engine currently supports only Windows!"
#endif

// ??????????????????????????????????????????????????????????????
// Eksport/import symboli
//  - EG_STATIC     ? budujemy/korzystamy ze statycznej biblioteki ? ENGINE_API puste
//  - EG_BUILD_DLL  ? budujemy DLL (export)
//  - (domyœlnie)   ? korzystamy z DLL (import)
// Uwaga: dla statycznej biblioteki ustaw w premake: defines { "EG_STATIC" } w obu projektach.
// ??????????????????????????????????????????????????????????????
#ifdef EG_PLATFORM_WINDOWS
#if defined(EG_STATIC)
#define ENGINE_API
#elif defined(EG_BUILD_DLL)
#define ENGINE_API __declspec(dllexport)
#else
#define ENGINE_API __declspec(dllimport)
#endif
#else
#define ENGINE_API
#endif

// ??????????????????????????????????????????????????????????????
#ifdef EG_DEBUG
#define EG_ENABLE_CHECKS
#endif

// Mo¿esz korzystaæ z EG_ERROR/EG_CORE_ERROR (definiowane w Log.h).
// Jeœli chcesz, dodaj tu fallback do assert/OutputDebugString.
#ifdef EG_ENABLE_CHECKS
#define EG_CHECK(expr, msg)      do { if(!(expr)) { EG_ERROR("Check failed: {0}", msg); __debugbreak(); } } while(0)
#define EG_CORE_CHECK(expr, msg) do { if(!(expr)) { EG_CORE_ERROR("Check failed: {0}", msg); __debugbreak(); } } while(0)
#else
#define EG_CHECK(expr, msg)      ((void)0)
#define EG_CORE_CHECK(expr, msg) ((void)0)
#endif

namespace Engine {

    // Zamiast BIT(x)
    constexpr unsigned int BitMask(unsigned int bit) { return 1u << bit; }

    // Helper do bindowania eventów (czytelniejszy ni¿ makro)
    template<typename T, typename Fn>
    auto BindEvent(T* instance, Fn&& fn) {
        return [instance, fn = std::forward<Fn>(fn)](auto&&... args) -> decltype(auto) {
            return (instance->*fn)(std::forward<decltype(args)>(args)...);
            };
    }

    // Aliasy pamiêci
    template<typename T>
    using Unique = std::unique_ptr<T>;
    template<typename T, typename... Args>
    constexpr Unique<T> MakeUnique(Args&&... args) {
        return std::make_unique<T>(std::forward<Args>(args)...);
    }

    template<typename T>
    using Shared = std::shared_ptr<T>;
    template<typename T, typename... Args>
    constexpr Shared<T> MakeShared(Args&&... args) {
        return std::make_shared<T>(std::forward<Args>(args)...);
    }

} // namespace Engine
